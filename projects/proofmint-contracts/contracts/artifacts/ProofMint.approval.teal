#pragma version 10

// This TEAL was generated by TEALScript v0.103.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(address)void
*abi_route_createApplication:
	// externalPayee: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (externalPayee) for createApplication must be a address
	assert

	// execute createApplication(address)void
	callsub createApplication
	int 1
	return

// createApplication(externalPayee: Address): void
createApplication:
	proto 1 0

	// contracts\ProofMint.algo.ts:27
	// this.globalMintCount.value = 0
	byte 0x676c6f62616c4d696e74436f756e74 // "globalMintCount"
	int 0
	app_global_put

	// contracts\ProofMint.algo.ts:28
	// this.externalPayeeAddress.value = externalPayee
	byte 0x65787465726e616c506179656541646472657373 // "externalPayeeAddress"
	frame_dig -1 // externalPayee: Address
	app_global_put
	retsub

// registerAccount(string,string,string,string,string)void
*abi_route_registerAccount:
	// contact: string
	txna ApplicationArgs 5
	extract 2 0

	// email: string
	txna ApplicationArgs 4
	extract 2 0

	// year: string
	txna ApplicationArgs 3
	extract 2 0

	// name: string
	txna ApplicationArgs 2
	extract 2 0

	// role: string
	txna ApplicationArgs 1
	extract 2 0

	// execute registerAccount(string,string,string,string,string)void
	callsub registerAccount
	int 1
	return

// registerAccount(role: string, name: string, year: string, email: string, contact: string): void
registerAccount:
	proto 5 0

	// contracts\ProofMint.algo.ts:32
	// assert(this.users(this.txn.sender).exists === false, 'User already exists')
	txn Sender
	box_len
	swap
	pop
	int 0
	==

	// User already exists
	assert

	// *if0_condition
	// contracts\ProofMint.algo.ts:33
	// role === 'institution' || role === 'company' || role === 'doa' || role === 'community'
	frame_dig -1 // role: string
	byte 0x696e737469747574696f6e // "institution"
	==
	dup
	bnz *skip_or0
	frame_dig -1 // role: string
	byte 0x636f6d70616e79 // "company"
	==
	||

*skip_or0:
	dup
	bnz *skip_or1
	frame_dig -1 // role: string
	byte 0x646f61 // "doa"
	==
	||

*skip_or1:
	dup
	bnz *skip_or2
	frame_dig -1 // role: string
	byte 0x636f6d6d756e697479 // "community"
	==
	||

*skip_or2:
	bz *if0_elseif1_condition

	// *if0_consequent
	// contracts\ProofMint.algo.ts:34
	// this.users(this.txn.sender).value = { role: role, name: name, year: year, email: email, contact: contact }
	txn Sender
	dup
	box_del
	pop
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x000a // initial head offset
	frame_dig -1 // role: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -2 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -3 // year: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -4 // email: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -5 // contact: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	box_put
	b *if0_end

*if0_elseif1_condition:
	// contracts\ProofMint.algo.ts:35
	// role === 'user'
	frame_dig -1 // role: string
	byte 0x75736572 // "user"
	==
	bz *if0_end

	// *if0_elseif1_consequent
	// contracts\ProofMint.algo.ts:36
	// this.users(this.txn.sender).value = { role: 'user', name: name, year: '', email: email, contact: contact }
	txn Sender
	dup
	box_del
	pop
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x000a // initial head offset
	byte 0x000475736572
	callsub *process_dynamic_tuple_element
	frame_dig -2 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	byte 0x0000
	callsub *process_dynamic_tuple_element
	frame_dig -4 // email: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -5 // contact: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	box_put

*if0_end:
	retsub

// registerMint(uint64,address[],pay)void
*abi_route_registerMint:
	// costs: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 0 (costs) for registerMint must be a pay transaction
	assert

	// addresses: address[]
	txna ApplicationArgs 2
	extract 2 0

	// assetId: uint64
	txna ApplicationArgs 1
	btoi

	// execute registerMint(uint64,address[],pay)void
	callsub registerMint
	int 1
	return

// registerMint(assetId: AssetID, addresses: Address[], costs: PayTxn): void
registerMint:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// contracts\ProofMint.algo.ts:41
	// assert(addresses.length > 0, 'No addresses provided')
	frame_dig -2 // addresses: Address[]
	len
	int 32
	/
	int 0
	>

	// No addresses provided
	assert

	// contracts\ProofMint.algo.ts:42
	// assert(assetId.clawback === this.app.address, 'Clawback address must be the app address')
	frame_dig -1 // assetId: AssetID
	asset_params_get AssetClawback
	pop
	global CurrentApplicationAddress
	==

	// Clawback address must be the app address
	assert

	// contracts\ProofMint.algo.ts:43
	// assert(assetId.creator.assetBalance(assetId) >= addresses.length, 'Not enough assets')
	frame_dig -1 // assetId: AssetID
	asset_params_get AssetCreator
	pop
	frame_dig -1 // assetId: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -2 // addresses: Address[]
	len
	int 32
	/
	>=

	// Not enough assets
	assert

	// contracts\ProofMint.algo.ts:44
	// assert(this.mints(assetId.id).exists === false, 'Mint already exists')
	frame_dig -1 // assetId: AssetID
	itob
	box_len
	swap
	pop
	int 0
	==

	// Mint already exists
	assert

	// contracts\ProofMint.algo.ts:45
	// mintCount = this.globalMintCount.value + 1
	byte 0x676c6f62616c4d696e74436f756e74 // "globalMintCount"
	app_global_get
	int 1
	+
	frame_bury 0 // mintCount: uint64

	// contracts\ProofMint.algo.ts:46
	// this.globalMintCount.value = mintCount
	byte 0x676c6f62616c4d696e74436f756e74 // "globalMintCount"
	frame_dig 0 // mintCount: uint64
	app_global_put

	// contracts\ProofMint.algo.ts:47
	// cost = 2500 + 3200 + 34 * addresses.length * 400 + addresses.length * 205000 + 1000
	int 5700
	int 34
	frame_dig -2 // addresses: Address[]
	len
	int 32
	/
	*
	int 400
	*
	+
	frame_dig -2 // addresses: Address[]
	len
	int 32
	/
	int 205000
	*
	+
	int 1000
	+
	frame_bury 1 // cost: uint64

	// contracts\ProofMint.algo.ts:48
	// verifyPayTxn(costs, { amount: { greaterThanEqualTo: cost }, receiver: this.app.address })
	// verify amount
	frame_dig -3 // costs: PayTxn
	gtxns Amount
	frame_dig 1 // cost: uint64
	>=

	// transaction verification failed: {"txn":"costs","field":"amount","condition":"greaterThanEqualTo","expected":">=cost"}
	assert

	// verify receiver
	frame_dig -3 // costs: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"costs","field":"receiver","expected":"this.app.address"}
	assert

	// contracts\ProofMint.algo.ts:49
	// sendPayment({ receiver: this.externalPayeeAddress.value, amount: addresses.length * 1000, fee: 1000 })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts\ProofMint.algo.ts:49
	// receiver: this.externalPayeeAddress.value
	byte 0x65787465726e616c506179656541646472657373 // "externalPayeeAddress"
	app_global_get
	itxn_field Receiver

	// contracts\ProofMint.algo.ts:49
	// amount: addresses.length * 1000
	frame_dig -2 // addresses: Address[]
	len
	int 32
	/
	int 1000
	*
	itxn_field Amount

	// contracts\ProofMint.algo.ts:49
	// fee: 1000
	int 1000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\ProofMint.algo.ts:50
	// addressClaims: AddressClaim[] = []
	byte 0x
	frame_bury 2 // addressClaims: AddressClaim[]

	// contracts\ProofMint.algo.ts:51
	// for (let i = 0; i < addresses.length; i += 1)
	int 0
	frame_bury 3 // i: uint64

*for_0:
	// contracts\ProofMint.algo.ts:51
	// i < addresses.length
	frame_dig 3 // i: uint64
	frame_dig -2 // addresses: Address[]
	len
	int 32
	/
	<
	bz *for_0_end

	// contracts\ProofMint.algo.ts:52
	// oneAddressClaim: AddressClaim = { address: addresses[i], nftClaim: 0, mbrClaim: 0 }
	frame_dig -2 // addresses: Address[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 3 // i: uint64
	int 32
	* // acc * typeLength
	+
	load 255 // full array
	swap
	int 32
	extract3
	byte 0x00
	concat
	byte 0x00
	concat
	frame_bury 4 // oneAddressClaim: AddressClaim

	// contracts\ProofMint.algo.ts:53
	// addressClaims.push(oneAddressClaim)
	frame_dig 2 // addressClaims: AddressClaim[]
	frame_dig 4 // oneAddressClaim: AddressClaim
	concat
	frame_bury 2 // addressClaims: AddressClaim[]

*for_0_continue:
	// contracts\ProofMint.algo.ts:51
	// i += 1
	frame_dig 3 // i: uint64
	int 1
	+
	frame_bury 3 // i: uint64
	b *for_0

*for_0_end:
	// contracts\ProofMint.algo.ts:55
	// this.mints(assetId.id).value = addressClaims
	frame_dig -1 // assetId: AssetID
	itob
	dup
	box_del
	pop
	frame_dig 2 // addressClaims: AddressClaim[]
	dup
	len
	int 34
	/
	itob
	extract 6 2
	swap
	concat
	box_put
	retsub

// claimNft(uint64)void
*abi_route_claimNft:
	// assetId: uint64
	txna ApplicationArgs 1
	btoi

	// execute claimNft(uint64)void
	callsub claimNft
	int 1
	return

// claimNft(assetId: AssetID): void
claimNft:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\ProofMint.algo.ts:59
	// assert(this.mints(assetId.id).exists, 'No mint found')
	frame_dig -1 // assetId: AssetID
	itob
	box_len
	swap
	pop

	// No mint found
	assert

	// contracts\ProofMint.algo.ts:60
	// assert(assetId.clawback === this.app.address, 'Clawback address must be the app address')
	frame_dig -1 // assetId: AssetID
	asset_params_get AssetClawback
	pop
	global CurrentApplicationAddress
	==

	// Clawback address must be the app address
	assert

	// contracts\ProofMint.algo.ts:61
	// checkResult = this.checkAddressAvailable(assetId, this.txn.sender)
	txn Sender
	frame_dig -1 // assetId: AssetID
	callsub checkAddressAvailable
	frame_bury 0 // checkResult: (bool,uint64,(address,uint8,uint8))

	// contracts\ProofMint.algo.ts:62
	// assert(checkResult[0], 'Address not found')
	frame_dig 0 // checkResult: (bool,uint64,(address,uint8,uint8))
	store 255 // full array
	load 255 // full array
	int 0
	getbit

	// Address not found
	assert

	// contracts\ProofMint.algo.ts:63
	// assert(checkResult[2].nftClaim === 0, 'Address already claimed')
	frame_dig 0 // checkResult: (bool,uint64,(address,uint8,uint8))
	store 255 // full array
	load 255 // full array
	extract 41 1
	btoi
	int 0
	==

	// Address already claimed
	assert

	// contracts\ProofMint.algo.ts:64
	// assert(this.txn.sender.isOptedInToAsset(assetId), 'Address not opted in to asset')
	txn Sender
	frame_dig -1 // assetId: AssetID
	asset_holding_get AssetBalance
	swap
	pop

	// Address not opted in to asset
	assert

	// contracts\ProofMint.algo.ts:65
	// this.changeAddressClaimNft(assetId, checkResult[1])
	frame_dig 0 // checkResult: (bool,uint64,(address,uint8,uint8))
	store 255 // full array
	load 255 // full array
	extract 1 8
	btoi
	frame_dig -1 // assetId: AssetID
	callsub changeAddressClaimNft

	// contracts\ProofMint.algo.ts:66
	// sendAssetTransfer({
	//       sender: this.app.address,
	//       assetSender: assetId.creator,
	//       assetReceiver: this.txn.sender,
	//       assetAmount: 1,
	//       xferAsset: assetId,
	//       fee: 1000,
	//       note: 'claimnft-' + assetId.id.toString(),
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts\ProofMint.algo.ts:67
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts\ProofMint.algo.ts:68
	// assetSender: assetId.creator
	frame_dig -1 // assetId: AssetID
	asset_params_get AssetCreator
	pop
	itxn_field AssetSender

	// contracts\ProofMint.algo.ts:69
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts\ProofMint.algo.ts:70
	// assetAmount: 1
	int 1
	itxn_field AssetAmount

	// contracts\ProofMint.algo.ts:71
	// xferAsset: assetId
	frame_dig -1 // assetId: AssetID
	itxn_field XferAsset

	// contracts\ProofMint.algo.ts:72
	// fee: 1000
	int 1000
	itxn_field Fee

	// contracts\ProofMint.algo.ts:73
	// note: 'claimnft-' + assetId.id.toString()
	byte 0x636c61696d6e66742d // "claimnft-"
	frame_dig -1 // assetId: AssetID
	callsub *itoa
	concat
	itxn_field Note

	// Submit inner transaction
	itxn_submit
	retsub

// claimMbr(uint64,address)void
*abi_route_claimMbr:
	// address: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (address) for claimMbr must be a address
	assert

	// assetId: uint64
	txna ApplicationArgs 1
	btoi

	// execute claimMbr(uint64,address)void
	callsub claimMbr
	int 1
	return

// claimMbr(assetId: AssetID, address: Address): void
claimMbr:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\ProofMint.algo.ts:78
	// assert(this.mints(assetId.id).exists, 'No mint found')
	frame_dig -1 // assetId: AssetID
	itob
	box_len
	swap
	pop

	// No mint found
	assert

	// contracts\ProofMint.algo.ts:79
	// assert(assetId.clawback === this.app.address, 'Clawback address must be the app address')
	frame_dig -1 // assetId: AssetID
	asset_params_get AssetClawback
	pop
	global CurrentApplicationAddress
	==

	// Clawback address must be the app address
	assert

	// contracts\ProofMint.algo.ts:80
	// assert(this.txn.sender === this.externalPayeeAddress.value, 'Only external payee can claim')
	txn Sender
	byte 0x65787465726e616c506179656541646472657373 // "externalPayeeAddress"
	app_global_get
	==

	// Only external payee can claim
	assert

	// contracts\ProofMint.algo.ts:81
	// checkResult = this.checkAddressAvailable(assetId, address)
	frame_dig -2 // address: Address
	frame_dig -1 // assetId: AssetID
	callsub checkAddressAvailable
	frame_bury 0 // checkResult: (bool,uint64,(address,uint8,uint8))

	// contracts\ProofMint.algo.ts:82
	// assert(checkResult[0], 'Address not found')
	frame_dig 0 // checkResult: (bool,uint64,(address,uint8,uint8))
	store 255 // full array
	load 255 // full array
	int 0
	getbit

	// Address not found
	assert

	// contracts\ProofMint.algo.ts:83
	// assert(checkResult[2].mbrClaim === 0, 'Address already claimed')
	frame_dig 0 // checkResult: (bool,uint64,(address,uint8,uint8))
	store 255 // full array
	load 255 // full array
	extract 42 1
	btoi
	int 0
	==

	// Address already claimed
	assert

	// contracts\ProofMint.algo.ts:84
	// this.changeAddressClaimMbr(assetId, checkResult[1])
	frame_dig 0 // checkResult: (bool,uint64,(address,uint8,uint8))
	store 255 // full array
	load 255 // full array
	extract 1 8
	btoi
	frame_dig -1 // assetId: AssetID
	callsub changeAddressClaimMbr

	// contracts\ProofMint.algo.ts:85
	// sendPayment({ receiver: address, amount: 202000, fee: 1000, note: 'claimmbr-' + assetId.id.toString() })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts\ProofMint.algo.ts:85
	// receiver: address
	frame_dig -2 // address: Address
	itxn_field Receiver

	// contracts\ProofMint.algo.ts:85
	// amount: 202000
	int 202000
	itxn_field Amount

	// contracts\ProofMint.algo.ts:85
	// fee: 1000
	int 1000
	itxn_field Fee

	// contracts\ProofMint.algo.ts:85
	// note: 'claimmbr-' + assetId.id.toString()
	byte 0x636c61696d6d62722d // "claimmbr-"
	frame_dig -1 // assetId: AssetID
	callsub *itoa
	concat
	itxn_field Note

	// Submit inner transaction
	itxn_submit
	retsub

// changeAddressClaimNft(assetId: AssetID, addressIndex: uint64): void
changeAddressClaimNft:
	proto 2 0

	// contracts\ProofMint.algo.ts:89
	// this.mints(assetId.id).value[addressIndex] = {
	//       address: this.mints(assetId.id).value[addressIndex].address,
	//       nftClaim: 1,
	//       mbrClaim: this.mints(assetId.id).value[addressIndex].mbrClaim,
	//     }
	frame_dig -1 // assetId: AssetID
	itob
	box_get

	// box value does not exist: this.mints(assetId.id).value
	assert
	extract 2 0
	store 255 // full array
	int 0 // initial offset
	frame_dig -2 // addressIndex: uint64
	int 34
	* // acc * typeLength
	+
	load 255 // full array
	swap
	frame_dig -1 // assetId: AssetID
	itob
	box_get

	// box value does not exist: this.mints(assetId.id).value
	assert
	extract 2 0
	store 255 // full array
	int 0 // initial offset
	frame_dig -2 // addressIndex: uint64
	int 34
	* // acc * typeLength
	+
	int 0 // headOffset
	+
	load 255 // full array
	swap
	int 32
	extract3
	byte 0x01
	concat
	frame_dig -1 // assetId: AssetID
	itob
	box_get

	// box value does not exist: this.mints(assetId.id).value
	assert
	extract 2 0
	store 255 // full array
	int 0 // initial offset
	frame_dig -2 // addressIndex: uint64
	int 34
	* // acc * typeLength
	+
	int 33 // headOffset
	+
	load 255 // full array
	swap
	int 1
	extract3
	btoi
	itob
	extract 7 1
	concat
	replace3
	frame_dig -1 // assetId: AssetID
	itob
	dup
	box_del
	pop
	swap
	dup
	len
	int 34
	/
	itob
	extract 6 2
	swap
	concat
	box_put
	retsub

// changeAddressClaimMbr(assetId: AssetID, addressIndex: uint64): void
changeAddressClaimMbr:
	proto 2 0

	// contracts\ProofMint.algo.ts:97
	// this.mints(assetId.id).value[addressIndex] = {
	//       address: this.mints(assetId.id).value[addressIndex].address,
	//       nftClaim: this.mints(assetId.id).value[addressIndex].nftClaim,
	//       mbrClaim: 1,
	//     }
	frame_dig -1 // assetId: AssetID
	itob
	box_get

	// box value does not exist: this.mints(assetId.id).value
	assert
	extract 2 0
	store 255 // full array
	int 0 // initial offset
	frame_dig -2 // addressIndex: uint64
	int 34
	* // acc * typeLength
	+
	load 255 // full array
	swap
	frame_dig -1 // assetId: AssetID
	itob
	box_get

	// box value does not exist: this.mints(assetId.id).value
	assert
	extract 2 0
	store 255 // full array
	int 0 // initial offset
	frame_dig -2 // addressIndex: uint64
	int 34
	* // acc * typeLength
	+
	int 0 // headOffset
	+
	load 255 // full array
	swap
	int 32
	extract3
	frame_dig -1 // assetId: AssetID
	itob
	box_get

	// box value does not exist: this.mints(assetId.id).value
	assert
	extract 2 0
	store 255 // full array
	int 0 // initial offset
	frame_dig -2 // addressIndex: uint64
	int 34
	* // acc * typeLength
	+
	int 32 // headOffset
	+
	load 255 // full array
	swap
	int 1
	extract3
	btoi
	itob
	extract 7 1
	concat
	byte 0x01
	concat
	replace3
	frame_dig -1 // assetId: AssetID
	itob
	dup
	box_del
	pop
	swap
	dup
	len
	int 34
	/
	itob
	extract 6 2
	swap
	concat
	box_put
	retsub

// checkAddressAvailable(assetId: AssetID, address: Address): [boolean, uint64, AddressClaim]
checkAddressAvailable:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 5

	// contracts\ProofMint.algo.ts:105
	// addresses = this.mints(assetId.id).value
	frame_dig -1 // assetId: AssetID
	itob
	frame_bury 0 // storage key//addresses

	// contracts\ProofMint.algo.ts:106
	// addressesLength = this.mints(assetId.id).size / 33
	frame_dig -1 // assetId: AssetID
	itob
	box_len

	// box value does not exist: this.mints(assetId.id).size
	assert
	int 33
	/
	frame_bury 1 // addressesLength: uint64

	// contracts\ProofMint.algo.ts:107
	// addressFound = false
	int 0
	frame_bury 2 // addressFound: bool

	// contracts\ProofMint.algo.ts:108
	// addressIndex = 0
	int 0
	frame_bury 3 // addressIndex: uint64

	// contracts\ProofMint.algo.ts:109
	// addressClaim: AddressClaim = { address: address, nftClaim: 0, mbrClaim: 0 }
	frame_dig -2 // address: Address
	byte 0x00
	concat
	byte 0x00
	concat
	frame_bury 4 // addressClaim: AddressClaim

	// contracts\ProofMint.algo.ts:110
	// for (let i = 0; i < addressesLength; i += 1)
	int 0
	frame_bury 5 // i: uint64

*for_1:
	// contracts\ProofMint.algo.ts:110
	// i < addressesLength
	frame_dig 5 // i: uint64
	frame_dig 1 // addressesLength: uint64
	<
	bz *for_1_end

	// *if1_condition
	// contracts\ProofMint.algo.ts:111
	// addresses[i].address === address
	frame_dig 0 // storage key//addresses
	box_get

	// box value does not exist: this.mints(assetId.id).value
	assert
	extract 2 0
	store 255 // full array
	int 0 // initial offset
	frame_dig 5 // i: uint64
	int 34
	* // acc * typeLength
	+
	int 0 // headOffset
	+
	load 255 // full array
	swap
	int 32
	extract3
	frame_dig -2 // address: Address
	==
	bz *if1_end

	// *if1_consequent
	// contracts\ProofMint.algo.ts:112
	// addressFound = true
	int 1
	frame_bury 2 // addressFound: bool

	// contracts\ProofMint.algo.ts:113
	// addressIndex = i
	frame_dig 5 // i: uint64
	frame_bury 3 // addressIndex: uint64

	// contracts\ProofMint.algo.ts:114
	// addressClaim = addresses[i]
	frame_dig 0 // storage key//addresses
	box_get

	// box value does not exist: this.mints(assetId.id).value
	assert
	extract 2 0
	store 255 // full array
	int 0 // initial offset
	frame_dig 5 // i: uint64
	int 34
	* // acc * typeLength
	+
	load 255 // full array
	swap
	int 34
	extract3
	frame_bury 4 // addressClaim: AddressClaim
	b *for_1_end

*if1_end:

*for_1_continue:
	// contracts\ProofMint.algo.ts:110
	// i += 1
	frame_dig 5 // i: uint64
	int 1
	+
	frame_bury 5 // i: uint64
	b *for_1

*for_1_end:
	// contracts\ProofMint.algo.ts:118
	// return [addressFound, addressIndex, addressClaim];
	byte 0x00
	int 0
	frame_dig 2 // addressFound: bool
	setbit
	frame_dig 3 // addressIndex: uint64
	itob
	concat
	frame_dig 4 // addressClaim: AddressClaim
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 5
	retsub

*create_NoOp:
	method "createApplication(address)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "registerAccount(string,string,string,string,string)void"
	method "registerMint(uint64,address[],pay)void"
	method "claimNft(uint64)void"
	method "claimMbr(uint64,address)void"
	txna ApplicationArgs 0
	match *abi_route_registerAccount *abi_route_registerMint *abi_route_claimNft *abi_route_claimMbr

	// this contract does not implement the given ABI method for call NoOp
	err

*intToAscii:
	proto 1 1
	byte 0x30313233343536373839 // "0123456789"
	frame_dig -1 // i: uint64
	int 1
	extract3
	retsub
	

*itoa:
	proto 1 1
	frame_dig -1 // i: uint64
	int 0
	==
	bz *itoa_if_end
	byte 0x30
	retsub

*itoa_if_end:
	frame_dig -1 // i: uint64
	int 10
	/
	int 0
	>
	bz *itoa_ternary_false
	frame_dig -1 // i: uint64
	int 10
	/
	callsub *itoa
	b *itoa_ternary_end

*itoa_ternary_false:
	byte 0x // ""

*itoa_ternary_end:
	frame_dig -1 // i: uint64
	int 10
	%
	callsub *intToAscii
	concat
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub